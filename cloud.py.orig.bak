import streamlit as st
import sqlite3
import hashlib
import json
from datetime import datetime, time, date
import pandas as pd
import difflib
# ---------- BEGIN: MongoDB adapter (paste into cloud.py replacing sqlite DB functions) ----------
# NOTE: place this near the top of cloud.py where DB functions are defined,
# replacing the original SQLite-based functions (init_db, create_user, get_user_by_email, delete_user, etc.)

from datetime import datetime
from bson import ObjectId
from bson.json_util import dumps as bson_dumps
import pymongo
import os
from dotenv import load_dotenv

load_dotenv()  # ensure .env is loaded

# Import the mongo_db module created earlier (it exposes collections)
try:
    from mongo_db import db, users_coll, patients_coll, doctors_coll, appointments_coll, symptom_records_coll, notes_coll
except Exception:
    # fallback: create client directly if mongo_db not present
    from pymongo import MongoClient
    MONGO_URI = os.getenv("MONGO_URI")
    MONGO_DB_NAME = os.getenv("MONGO_DB_NAME", "health_management")
    if not MONGO_URI:
        raise RuntimeError("MONGO_URI is not set. Please add it to .env.")
    client = MongoClient(MONGO_URI)
    db = client[MONGO_DB_NAME]
    users_coll = db['users']
    patients_coll = db['patients']
    doctors_coll = db['doctors']
    appointments_coll = db['appointments']
    symptom_records_coll = db['symptom_records']
    notes_coll = db['notes']

# Utility: serialize a Mongo document to friendly JSON-compatible python dict
def serialize_doc(doc):
    if doc is None:
        return None
    out = {}
    for k, v in doc.items():
        # Convert ObjectId to string
        if isinstance(v, ObjectId):
            out[k] = str(v)
        # Convert datetime to ISO
        elif isinstance(v, datetime):
            out[k] = v.isoformat()
        # Convert bytes if any (unlikely)
        elif isinstance(v, bytes):
            try:
                out[k] = v.decode()
            except Exception:
                out[k] = str(v)
        # For nested documents or lists, attempt recursive conversion
        elif isinstance(v, dict):
            out[k] = serialize_doc(v)
        elif isinstance(v, list):
            new_list = []
            for item in v:
                if isinstance(item, dict):
                    new_list.append(serialize_doc(item))
                elif isinstance(item, ObjectId):
                    new_list.append(str(item))
                elif isinstance(item, datetime):
                    new_list.append(item.isoformat())
                else:
                    new_list.append(item)
            out[k] = new_list
        else:
            out[k] = v
    return out

# Init DB (noop for Mongo)
def init_db():
    # Ensure indexes (optional)
    users_coll.create_index("username", unique=True)
    patients_coll.create_index("user_id")
    doctors_coll.create_index("user_id")
    appointments_coll.create_index("patient_id")
    symptom_records_coll.create_index("patient_id")
    # nothing else required for Mongo (collections created on insert)
    return True

# User functions
def hash_password(password):
    # keep existing hashing logic in cloud.py (sha256) OR use passlib if available
    import hashlib
    return hashlib.sha256(password.encode()).hexdigest()

def create_user(username, password, role):
    hashed_pw = hash_password(password)
    doc = {
        "username": username,
        "password": hashed_pw,
        "role": role,
        "created_at": datetime.utcnow()
    }
    try:
        res = users_coll.insert_one(doc)
        return str(res.inserted_id)
    except pymongo.errors.DuplicateKeyError:
        raise ValueError("Username already exists")

def get_user_by_username(username):
    doc = users_coll.find_one({"username": username})
    return serialize_doc(doc)

def get_user_by_email(email):
    # if you used email as username in original app, this maps; otherwise keep username functions
    doc = users_coll.find_one({"email": email})
    return serialize_doc(doc) if doc else None

def delete_user(username):
    users_coll.delete_one({"username": username})
    # Also optionally delete related docs
    patients_coll.delete_many({"user_id": username})
    doctors_coll.delete_many({"user_id": username})

def verify_user(username, password):
    doc = users_coll.find_one({"username": username})
    if not doc:
        return False
    return doc.get("password") == hash_password(password) or doc.get("password") == hash_password(password)

# Patient functions
def add_patient(user_id, full_name, age=None, gender=None, phone=None):
    doc = {
        "user_id": user_id,
        "full_name": full_name,
        "age": int(age) if age is not None and str(age).isdigit() else None,
        "gender": gender,
        "phone": phone,
        "created_at": datetime.utcnow()
    }
    res = patients_coll.insert_one(doc)
    return str(res.inserted_id)

def get_patient_by_id(pid):
    # pid may be integer id from SQLite; migrated documents keep original id field, so attempt both
    # Try ObjectId first
    try:
        if ObjectId.is_valid(pid):
            doc = patients_coll.find_one({"_id": ObjectId(pid)})
            if doc:
                return serialize_doc(doc)
    except Exception:
        pass
    # fallback: check for numeric/id field "id"
    doc = patients_coll.find_one({"id": pid})
    if not doc and isinstance(pid, (int, str)) and str(pid).isdigit():
        doc = patients_coll.find_one({"id": int(pid)})
    return serialize_doc(doc) if doc else None

def list_patients_for_user(user_id):
    cursor = patients_coll.find({"user_id": user_id}).sort("created_at", -1)
    return [serialize_doc(d) for d in cursor]

# Doctor functions
def add_doctor(user_id, name, specialization=None, phone=None):
    doc = {
        "user_id": user_id,
        "name": name,
        "specialization": specialization,
        "phone": phone,
        "created_at": datetime.utcnow()
    }
    res = doctors_coll.insert_one(doc)
    return str(res.inserted_id)

def get_doctor_by_user_id(user_id):
    doc = doctors_coll.find_one({"user_id": user_id})
    return serialize_doc(doc) if doc else None

# Appointments
def create_appointment(patient_id, doctor_id, when_dt, notes=None):
    if isinstance(when_dt, str):
        try:
            when_dt = datetime.fromisoformat(when_dt)
        except Exception:
            pass
    doc = {
        "patient_id": patient_id,
        "doctor_id": doctor_id,
        "when": when_dt,
        "notes": notes,
        "created_at": datetime.utcnow()
    }
    res = appointments_coll.insert_one(doc)
    return str(res.inserted_id)

def get_appointments_for_patient(patient_id):
    cursor = appointments_coll.find({"patient_id": patient_id}).sort("when", -1)
    return [serialize_doc(d) for d in cursor]

# Symptom records / notes
def add_symptom_record(patient_id, symptoms, duration, previous_diagnosis):
    doc = {
        "patient_id": patient_id,
        "symptoms": symptoms,
        "duration": duration,
        "previous_diagnosis": previous_diagnosis,
        "recorded_at": datetime.utcnow()
    }
    res = symptom_records_coll.insert_one(doc)
    return str(res.inserted_id)

def get_symptom_records(patient_id):
    cursor = symptom_records_coll.find({"patient_id": patient_id}).sort("recorded_at", -1)
    return [serialize_doc(d) for d in cursor]

def add_note(patient_id, doctor_id, note):
    doc = {
        "patient_id": patient_id,
        "doctor_id": doctor_id,
        "note": note,
        "created_at": datetime.utcnow()
    }
    res = notes_coll.insert_one(doc)
    return str(res.inserted_id)

def get_notes_for_patient(patient_id):
    cursor = notes_coll.find({"patient_id": patient_id}).sort("created_at", -1)
    return [serialize_doc(d) for d in cursor]

# ---------- END: MongoDB adapter ----------

# ==============================
# THEME & STYLES
# ==============================
THEMES = {
    "Azure": {
        "--primary": "#3B82F6",
        "--accent": "#60A5FA",
        "--ok": "#10B981",
        "--warn": "#F59E0B",
        "--danger": "#EF4444",
        "--text": "#0F172A",
        "--muted": "#64748B",
        "--glass": "rgba(255,255,255,0.6)",
        "--glass-dark": "rgba(15,23,42,0.55)",
        "--bg-grad-light": "linear-gradient(135deg,#F8FAFC 0%, #EEF2FF 100%)",
        "--bg-grad-dark": "linear-gradient(135deg,#0B1220 0%, #0F172A 100%)",
    },
    "Emerald": {
        "--primary": "#10B981",
        "--accent": "#34D399",
        "--ok": "#22C55E",
        "--warn": "#EAB308",
        "--danger": "#F43F5E",
        "--text": "#052E2B",
        "--muted": "#4B5563",
        "--glass": "rgba(255,255,255,0.6)",
        "--glass-dark": "rgba(5,46,43,0.55)",
        "--bg-grad-light": "linear-gradient(135deg,#F0FDF4 0%, #ECFDF5 100%)",
        "--bg-grad-dark": "linear-gradient(135deg,#021614 0%, #052E2B 100%)",
    },
    "Crimson": {
        "--primary": "#EF4444",
        "--accent": "#FB7185",
        "--ok": "#F59E0B",
        "--warn": "#F97316",
        "--danger": "#DC2626",
        "--text": "#1F2937",
        "--muted": "#6B7280",
        "--glass": "rgba(255,255,255,0.6)",
        "--glass-dark": "rgba(31,41,55,0.55)",
        "--bg-grad-light": "linear-gradient(135deg,#FFF1F2 0%, #FFE4E6 100%)",
        "--bg-grad-dark": "linear-gradient(135deg,#1F0E11 0%, #2B0F13 100%)",
    },
}

def inject_css(theme_name: str, dark: bool):
    t = THEMES.get(theme_name, THEMES["Azure"])
    glass = t["--glass-dark"] if dark else t["--glass"]
    bg = t["--bg-grad-dark"] if dark else t["--bg-grad-light"]
    text = "#E5E7EB" if dark else t["--text"]
    muted = "#9CA3AF" if dark else t["--muted"]

    st.markdown(
        f"""
        <style>
        :root {{
          --primary: {t["--primary"]};
          --accent: {t["--accent"]};
          --ok: {t["--ok"]};
          --warn: {t["--warn"]};
          --danger: {t["--danger"]};
          --text: {text};
          --muted: {muted};
        }}
        .stApp {{ background: {bg} !important; }}
        .hero {{
          border-radius: 18px; padding: 24px 22px; margin-bottom: 16px;
          background: {glass}; backdrop-filter: saturate(120%) blur(12px);
          border: 1px solid rgba(255,255,255,0.25);
          box-shadow: 0 10px 28px rgba(0,0,0,0.06);
        }}
        .hero h1 {{ color: var(--text); margin: 0; letter-spacing: -0.02em; }}
        .hero p {{ color: var(--muted); margin: 6px 0 0 0; font-size: 0.95rem; }}
        .card {{
          background: {glass}; border-radius: 16px; padding: 16px 16px;
          border: 1px solid rgba(255,255,255,0.25);
          box-shadow: 0 6px 22px rgba(0,0,0,0.05); margin-bottom: 12px;
        }}
        .stButton>button {{
          background: var(--primary) !important; color: white !important; border: none !important;
          border-radius: 12px !important; padding: 0.6rem 0.9rem !important; font-weight: 600 !important;
          transition: transform .05s ease;
        }}
        .stButton>button:hover {{ transform: translateY(-1px); filter: brightness(1.02); }}
        .stButton>button:active {{ transform: translateY(0px) scale(.98); }}
        .stTextInput>div>div>input, .stTextArea textarea, .stSelectbox>div>div, .stMultiSelect>div>div, .stDateInput input, .stTimeInput input {{
          border-radius: 12px !important;
        }}
        .stDataFrame{{ border-radius: 12px; overflow: hidden; }}
        .pill {{ display:inline-block; padding:6px 10px; border-radius:999px;
                 background: var(--accent); color:white; font-size:.8rem; font-weight:700; }}
        </style>
        """,
        unsafe_allow_html=True,
    )

def hero(title: str, subtitle: str):
    st.markdown(
        f"""
        <div class="hero">
          <h1>üè• {title}</h1>
          <p>{subtitle}</p>
        </div>
        """,
        unsafe_allow_html=True,
    )

def role_card(emoji: str, title: str, body: str, buttons: list[tuple]):
    with st.container():
        st.markdown(f"<div class='card'><h3 style='margin:0;color:var(--text)'>{emoji} {title}</h3>"
                    f"<p style='color:var(--muted);margin:.25rem 0 .75rem 0'>{body}</p>", unsafe_allow_html=True)
        cols = st.columns(len(buttons))
        for i, (label, key) in enumerate(buttons):
            with cols[i]:
                if st.button(label, use_container_width=True, key=key):
                    st.session_state.page = key
                    st.rerun()
        st.markdown("</div>", unsafe_allow_html=True)

# ==============================
# DATABASE
# ==============================
DB = "health_management.db"

def init_db():
    conn = sqlite3.connect(DB, check_same_thread=False)
    c = conn.cursor()
    # Users
    c.execute('''CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  password TEXT NOT NULL,
                  role TEXT NOT NULL,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
    # Patients
    c.execute('''CREATE TABLE IF NOT EXISTS patients
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  full_name TEXT NOT NULL,
                  age INTEGER,
                  gender TEXT,
                  phone TEXT,
                  email TEXT,
                  address TEXT,
                  FOREIGN KEY (user_id) REFERENCES users(id))''')
    # Doctors
    c.execute('''CREATE TABLE IF NOT EXISTS doctors
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  full_name TEXT NOT NULL,
                  specialization TEXT NOT NULL,
                  hospital_clinic TEXT NOT NULL,
                  phone TEXT,
                  email TEXT,
                  FOREIGN KEY (user_id) REFERENCES users(id))''')
    # Symptom notes
    c.execute('''CREATE TABLE IF NOT EXISTS symptom_records
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  patient_id INTEGER,
                  symptoms TEXT NOT NULL,
                  duration TEXT NOT NULL,
                  previous_diagnosis TEXT,
                  recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (patient_id) REFERENCES patients(id))''')
    # Triage
    c.execute('''CREATE TABLE IF NOT EXISTS triage_records
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  patient_id INTEGER NOT NULL,
                  selected_symptoms TEXT NOT NULL,
                  severity TEXT NOT NULL,
                  top_conditions TEXT NOT NULL,
                  recommended_specialty TEXT NOT NULL,
                  note TEXT,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (patient_id) REFERENCES patients(id))''')
    # Appointments
    c.execute('''CREATE TABLE IF NOT EXISTS appointments
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  patient_id INTEGER NOT NULL,
                  doctor_id INTEGER NOT NULL,
                  meeting_at TEXT NOT NULL,          -- ISO datetime
                  note TEXT,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY (patient_id) REFERENCES patients(id),
                  FOREIGN KEY (doctor_id) REFERENCES doctors(id))''')
    conn.commit()
    conn.close()

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def create_user(username, password, role):
    try:
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("INSERT INTO users (username, password, role) VALUES (?, ?, ?)",
                  (username, hash_password(password), role))
        user_id = c.lastrowid
        conn.commit()
        conn.close()
        return user_id
    except sqlite3.IntegrityError:
        return None

def verify_user(username, password, role):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT id FROM users WHERE username=? AND password=? AND role=?",
              (username, hash_password(password), role))
    result = c.fetchone()
    conn.close()
    return result[0] if result else None

def create_patient(user_id, full_name, age, gender, phone, email, address):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""INSERT INTO patients (user_id, full_name, age, gender, phone, email, address)
                 VALUES (?, ?, ?, ?, ?, ?, ?)""",
              (user_id, full_name, age, gender, phone, email, address))
    pid = c.lastrowid
    conn.commit()
    conn.close()
    return pid

def create_doctor(user_id, full_name, specialization, hospital_clinic, phone, email):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""INSERT INTO doctors (user_id, full_name, specialization, hospital_clinic, phone, email)
                 VALUES (?, ?, ?, ?, ?, ?)""",
              (user_id, full_name, specialization, hospital_clinic, phone, email))
    did = c.lastrowid
    conn.commit()
    conn.close()
    return did

def get_patient_by_user_id(user_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM patients WHERE user_id=?", (user_id,))
    row = c.fetchone()
    conn.close()
    return row

def get_doctor_by_user_id(user_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM doctors WHERE user_id=?", (user_id,))
    row = c.fetchone()
    conn.close()
    return row

def add_symptom_record(patient_id, symptoms, duration, previous_diagnosis):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""INSERT INTO symptom_records (patient_id, symptoms, duration, previous_diagnosis)
                 VALUES (?, ?, ?, ?)""",
              (patient_id, symptoms, duration, previous_diagnosis))
    conn.commit()
    conn.close()

def get_all_symptom_records_df():
    conn = sqlite3.connect(DB)
    q = """
        SELECT sr.id, p.id as patient_id, p.full_name, p.age, p.gender, sr.symptoms, sr.duration, 
               sr.previous_diagnosis, sr.recorded_at
        FROM symptom_records sr
        JOIN patients p ON sr.patient_id = p.id
        ORDER BY sr.recorded_at DESC
    """
    df = pd.read_sql_query(q, conn)
    conn.close()
    return df

def save_triage(patient_id: int, selected_symptoms: list, severity: str,
                top_conditions: list, specialty: str, note: str):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""INSERT INTO triage_records
            (patient_id, selected_symptoms, severity, top_conditions, recommended_specialty, note)
            VALUES(?,?,?,?,?,?)""",
            (patient_id, json.dumps(selected_symptoms), severity,
             json.dumps(top_conditions), specialty, note))
    conn.commit()
    conn.close()

def get_triage_df():
    conn = sqlite3.connect(DB)
    q = """
    SELECT t.id, t.created_at, t.patient_id, p.full_name, p.age, p.gender, 
           t.severity, t.recommended_specialty, t.selected_symptoms, t.top_conditions, t.note
    FROM triage_records t
    JOIN patients p ON t.patient_id = p.id
    ORDER BY datetime(t.created_at) DESC
    """
    df = pd.read_sql_query(q, conn)
    conn.close()
    def fmt_symptoms(x):
        try:
            arr = json.loads(x); return ", ".join(arr)
        except: return x
    def fmt_conditions(x):
        try:
            arr = json.loads(x); return ", ".join([f"{d['name']} ({int(round(d.get('score',0)*100))}%)" for d in arr])
        except: return x
    if not df.empty:
        df["selected_symptoms"] = df["selected_symptoms"].apply(fmt_symptoms)
        df["top_conditions"] = df["top_conditions"].apply(fmt_conditions)
    return df

def create_appointment(patient_id: int, doctor_id: int, meeting_iso: str, note: str):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""INSERT INTO appointments(patient_id, doctor_id, meeting_at, note)
                 VALUES(?,?,?,?)""", (patient_id, doctor_id, meeting_iso, note))
    conn.commit()
    conn.close()

def get_patient_appointments(patient_id: int) -> pd.DataFrame:
    conn = sqlite3.connect(DB)
    q = """
    SELECT a.id, a.meeting_at, a.note, a.created_at,
           d.full_name AS doctor_name, d.specialization, d.hospital_clinic
    FROM appointments a
    JOIN doctors d ON d.id = a.doctor_id
    WHERE a.patient_id = ?
    ORDER BY datetime(a.meeting_at) DESC
    """
    df = pd.read_sql_query(q, conn, params=(patient_id,))
    conn.close()
    return df

def get_latest_appointment(patient_id: int):
    conn = sqlite3.connect(DB)
    q = """
    SELECT a.id, a.meeting_at, a.note, a.created_at,
           d.full_name AS doctor_name, d.specialization, d.hospital_clinic
    FROM appointments a
    JOIN doctors d ON d.id = a.doctor_id
    WHERE a.patient_id = ?
    ORDER BY datetime(a.meeting_at) DESC
    LIMIT 1
    """
    cur = conn.cursor()
    cur.execute(q, (patient_id,))
    row = cur.fetchone()
    conn.close()
    return row

def get_latest_triage_per_patient() -> pd.DataFrame:
    conn = sqlite3.connect(DB)
    q = """
    WITH latest AS (
        SELECT patient_id, MAX(datetime(created_at)) AS max_t
        FROM triage_records
        GROUP BY patient_id
    )
    SELECT t.patient_id, t.recommended_specialty, t.severity, t.created_at,
           p.full_name, p.age, p.gender
    FROM triage_records t
    JOIN latest l ON l.patient_id = t.patient_id AND datetime(t.created_at) = l.max_t
    JOIN patients p ON p.id = t.patient_id
    """
    df = pd.read_sql_query(q, conn)
    conn.close()
    return df

# NEW: helper ‚Äî does this patient already have an appointment with a doctor of this specialty?
def patient_taken_by_specialty(patient_id: int, specialty: str) -> bool:
    """
    Returns True if the patient's latest appointment is with a doctor
    whose specialization matches `specialty` (case-insensitive, substring tolerant).
    """
    appt = get_latest_appointment(patient_id)
    if not appt:
        return False
    latest_spec = (appt[5] or "").strip().lower()
    my_spec = (specialty or "").strip().lower()
    # consider substring matches both ways to handle "Oncologist / Pulmonologist" etc.
    return (my_spec in latest_spec) or (latest_spec in my_spec)

# ==============================
# SESSION
# ==============================
def init_session_state():
    defaults = {
        'logged_in': False,
        'user_role': None,
        'user_id': None,
        'page': 'main',
        'theme': 'Azure',
        'dark': False,
        'chat_messages': [],
        'checker_key': 0,
        'show_chat': False,
    }
    for k, v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

def logout_reset():
    st.session_state.logged_in = False
    st.session_state.user_role = None
    st.session_state.user_id = None
    st.session_state.page = 'main'
    st.session_state.chat_messages = []
    st.session_state.show_chat = False
    st.toast("Logged out", icon="üëã")
    st.rerun()

# ==============================
# DISEASE KB & ONE-BEST CLASSIFIER
# ==============================
DISEASE_KB = [
    # Mild (12)
    {"name":"Common Cold","severity":"mild","specialty":"General Physician","keywords":["cold","common cold","rhinitis","runny nose","sore throat"]},
    {"name":"Seasonal Allergy","severity":"mild","specialty":"Allergist / Immunologist","keywords":["allergy","allergic rhinitis","hay fever"]},
    {"name":"Conjunctivitis","severity":"mild","specialty":"Ophthalmologist","keywords":["pink eye","conjunctivitis","eye redness"]},
    {"name":"Tension Headache","severity":"mild","specialty":"General Physician","keywords":["tension headache","stress headache"]},
    {"name":"Gastritis / Acid Reflux","severity":"mild","specialty":"Gastroenterologist","keywords":["gastritis","acid reflux","acidity","gerd","heartburn"]},
    {"name":"Dermatitis (mild)","severity":"mild","specialty":"Dermatologist","keywords":["dermatitis","eczema","mild rash","itchy skin"]},
    {"name":"Viral Fever (low-grade)","severity":"mild","specialty":"General Physician","keywords":["viral fever","low grade fever"]},
    {"name":"Acne (mild)","severity":"mild","specialty":"Dermatologist","keywords":["acne","pimples"]},
    {"name":"Sinusitis (mild)","severity":"mild","specialty":"ENT","keywords":["sinusitis","sinus infection","sinus pain"]},
    {"name":"Mouth Ulcer (aphthous)","severity":"mild","specialty":"Dentist","keywords":["mouth ulcer","aphthous ulcer","canker sore"]},
    {"name":"Otitis Externa (mild)","severity":"mild","specialty":"ENT","keywords":["swimmer's ear","otitis externa"]},
    {"name":"Mild Diarrhea","severity":"mild","specialty":"General Physician","keywords":["mild diarrhea","loose motions"]},
    # Moderate (10)
    {"name":"Influenza","severity":"moderate","specialty":"General Physician","keywords":["influenza","flu","high fever body ache"]},
    {"name":"Acute Gastroenteritis","severity":"moderate","specialty":"Gastroenterologist","keywords":["gastroenteritis","food poisoning","vomiting and diarrhea"]},
    {"name":"Urinary Tract Infection","severity":"moderate","specialty":"Urologist","keywords":["uti","urinary tract infection","burning urination"]},
    {"name":"Migraine","severity":"moderate","specialty":"Neurologist","keywords":["migraine","one sided headache","throbbing headache"]},
    {"name":"Asthma Exacerbation","severity":"moderate","specialty":"Pulmonologist","keywords":["asthma","wheezing","shortness of breath"]},
    {"name":"Bronchitis","severity":"moderate","specialty":"Pulmonologist","keywords":["bronchitis","chest congestion","productive cough"]},
    {"name":"Bacterial Sinusitis","severity":"moderate","specialty":"ENT","keywords":["bacterial sinusitis","purulent nasal discharge"]},
    {"name":"Iron-deficiency Anemia","severity":"moderate","specialty":"Hematologist","keywords":["anemia","iron deficiency","low hemoglobin"]},
    {"name":"Typhoid","severity":"moderate","specialty":"General Physician","keywords":["typhoid","enteric fever"]},
    {"name":"COVID-like Illness","severity":"moderate","specialty":"General Physician","keywords":["covid","loss of smell","covid like"]},
    # Serious (5)
    {"name":"Lung Cancer","severity":"serious","specialty":"Oncologist / Pulmonologist","keywords":["lung cancer","blood in cough","chronic cough weight loss"]},
    {"name":"Colorectal Cancer","severity":"serious","specialty":"Oncologist / Gastroenterologist","keywords":["colorectal cancer","blood in stool","weight loss bowel"]},
    {"name":"Breast Cancer","severity":"serious","specialty":"Oncologist","keywords":["breast cancer","breast lump","nipple discharge"]},
    {"name":"Gastric (Stomach) Cancer","severity":"serious","specialty":"Oncologist / Gastroenterologist","keywords":["stomach cancer","gastric cancer","early satiety weight loss"]},
    {"name":"Leukemia","severity":"serious","specialty":"Oncologist / Hematologist","keywords":["leukemia","abnormal blood counts","frequent infections"]},
]

TERM_TO_DISEASE = {}
for item in DISEASE_KB:
    TERM_TO_DISEASE[item["name"].lower()] = item
    for k in item["keywords"]:
        TERM_TO_DISEASE[k.lower()] = item

def classify_disease_from_text(query: str):
    q = (query or "").strip().lower()
    if not q:
        return {"name":"Undetermined Condition","score":0.0,"base_severity":"mild","specialty":"General Physician"}, "mild", "General Physician"

    candidates = list(set(list(TERM_TO_DISEASE.keys()) + [d["name"].lower() for d in DISEASE_KB]))
    scored = []

    # exact
    for item in DISEASE_KB:
        if item["name"].lower() == q:
            scored.append((item, 1.0))

    # keyword contains
    for term, meta in TERM_TO_DISEASE.items():
        if term in q or q in term:
            base = 0.95 if term == meta["name"].lower() else 0.85
            scored.append((meta, base))

    # fuzzy
    for term in candidates:
        ratio = difflib.SequenceMatcher(None, q, term).ratio()
        if ratio >= 0.6:
            meta = TERM_TO_DISEASE.get(term)
            if meta:
                scored.append((meta, max(0.70, min(0.90, ratio))))

    if not scored:
        best = {"name":"Undetermined Condition","score":0.0,"base_severity":"mild","specialty":"General Physician"}
        return best, "mild", "General Physician"

    best_by_name = {}
    for meta, s in scored:
        nm = meta["name"]
        if (nm not in best_by_name) or (s > best_by_name[nm][1]):
            best_by_name[nm] = (meta, s)

    best_meta, best_score = max(best_by_name.values(), key=lambda t: t[1])
    best = {
        "name": best_meta["name"],
        "score": float(f"{best_score:.3f}"),
        "base_severity": best_meta["severity"],
        "specialty": best_meta["specialty"],
    }
    overall = best["base_severity"]
    specialty = best["specialty"]
    return best, overall, specialty

DISEASE_ABOUT = {
    "Common Cold": "Viral upper-respiratory infection causing runny nose and sore throat; usually self-limited.",
    "Seasonal Allergy": "Allergic response to pollen/dust with sneezing and itchy/watery eyes.",
    "Conjunctivitis": "Inflammation of the eye‚Äôs conjunctiva; often contagious if infectious.",
    "Tension Headache": "Band-like, stress-related headache; typically non-throbbing.",
    "Gastritis / Acid Reflux": "Stomach acid irritation causing burning chest/upper-abdominal discomfort.",
    "Dermatitis (mild)": "Irritated/itchy skin; often triggered by contact or dryness.",
    "Viral Fever (low-grade)": "Short-lived fever with mild body aches; usually resolves with rest/fluids.",
    "Acne (mild)": "Clogged skin pores causing comedones and small inflamed bumps.",
    "Sinusitis (mild)": "Inflamed sinuses with facial pressure/congestion; often post-cold.",
    "Mouth Ulcer (aphthous)": "Small painful oral ulcers; heal in 1‚Äì2 weeks.",
    "Otitis Externa (mild)": "Ear-canal inflammation; often ‚Äòswimmer‚Äôs ear‚Äô.",
    "Mild Diarrhea": "Short-term loose stools; maintain hydration.",
    "Influenza": "Acute viral illness with high fever, myalgia, headache and cough.",
    "Acute Gastroenteritis": "Vomiting/diarrhea from gut inflammation; risk of dehydration.",
    "Urinary Tract Infection": "Burning urination, frequency; needs urine test ¬± antibiotics.",
    "Migraine": "Throbbing headache ¬± nausea/photophobia; often unilateral.",
    "Asthma Exacerbation": "Wheezing and breathlessness due to airway narrowing.",
    "Bronchitis": "Bronchial inflammation causing productive cough/chest congestion.",
    "Bacterial Sinusitis": "Persistent purulent discharge/facial pain; may need antibiotics.",
    "Iron-deficiency Anemia": "Low hemoglobin from iron lack ‚Üí fatigue, breathlessness on exertion.",
    "Typhoid": "Prolonged fever from salmonella; needs testing/antibiotics.",
    "COVID-like Illness": "Fever/cough ¬± loss of smell; get tested if available.",
    "Lung Cancer": "Persistent cough, weight loss, blood in sputum; needs imaging/oncology referral.",
    "Colorectal Cancer": "Blood in stool, weight loss, bowel changes; needs colon evaluation.",
    "Breast Cancer": "Breast lump or skin/nipple changes; needs imaging/biopsy.",
    "Gastric (Stomach) Cancer": "Early satiety, weight loss, persistent epigastric pain; needs endoscopy.",
    "Leukemia": "Abnormal blood counts, infections/bruising; needs hematology work-up.",
}

# ==============================
# PATIENT UI
# ==============================
def patient_registration():
    st.subheader("üë§ Patient Registration")
    st.caption("Create your account to securely check diseases and save records.")
    with st.form("patient_reg_form"):
        col1, col2 = st.columns(2)
        with col1:
            username = st.text_input("Username*")
            password = st.text_input("Password*", type="password")
            full_name = st.text_input("Full Name*")
            age = st.number_input("Age*", min_value=1, max_value=120, value=25)
        with col2:
            gender = st.selectbox("Gender*", ["Male", "Female", "Other"])
            phone = st.text_input("Phone Number*")
            email = st.text_input("Email*")
            address = st.text_area("Address")
        submitted = st.form_submit_button("Register")
    if submitted:
        if username and password and full_name and phone and email:
            user_id = create_user(username, password, "patient")
            if user_id:
                create_patient(user_id, full_name, age, gender, phone, email, address)
                st.success("Registration successful! Please login.")
                st.balloons()
                st.session_state.page = 'main'
                st.rerun()
            else:
                st.error("Username already exists!")
        else:
            st.error("Please fill all required fields!")

def patient_login():
    st.subheader("üîê Patient Login")
    with st.form("patient_login_form"):
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        c1, c2 = st.columns(2)
        with c1:
            submitted = st.form_submit_button("Login", use_container_width=True)
        with c2:
            back = st.form_submit_button("Back", use_container_width=True)
    if submitted:
        user_id = verify_user(username, password, "patient")
        if user_id:
            st.session_state.logged_in = True
            st.session_state.user_role = "patient"
            st.session_state.user_id = user_id
            st.toast("Welcome back!", icon="‚úÖ")
            st.rerun()
        else:
            st.error("Invalid credentials!")
    if back:
        st.session_state.page = 'main'
        st.rerun()

def patient_disease_checker(patient_id: int):
    st.subheader("ü©∫ Quick Disease Checker")
    st.caption("Educational triage only ‚Äî not a diagnosis. For emergencies, seek immediate care.")

    k = st.session_state.checker_key
    disease_guess = st.text_input(
        "What disease do you think you have?",
        placeholder="e.g., common cold, migraine, gastritis, breast cancer‚Ä¶",
        key=f"disease_guess_{k}"
    )
    note_text = st.text_area("Anything else you'd like to add? (optional)",
                             key=f"note_text_{k}")

    cols = st.columns([1,1,1])
    with cols[0]:
        check_save = st.button("Check & Save", use_container_width=True, key=f"check_{k}")
    with cols[1]:
        new_check = st.button("Start New Check", use_container_width=True, key=f"newcheck_{k}")
    with cols[2]:
        start_chat_btn = st.button("Start New Chat üí¨", use_container_width=True, key=f"chat_{k}")

    if new_check:
        st.session_state.checker_key += 1
        st.rerun()

    if start_chat_btn:
        st.session_state.chat_messages = []
        st.session_state.show_chat = True
        st.toast("New chat started", icon="üí¨")

    if check_save:
        if not disease_guess.strip():
            st.error("Please type a disease name.")
            return

        best, severity, specialty = classify_disease_from_text(disease_guess)

        sev_color = {"mild":"var(--ok)","moderate":"var(--warn)","serious":"var(--danger)"}[severity]
        st.markdown(
            f"#### Most likely: **{best['name']}**  ¬∑  match **{int(best['score']*100)}%**",
            unsafe_allow_html=True
        )
        about = DISEASE_ABOUT.get(best["name"], "No brief available.")
        st.markdown(f"<div class='card'><b>About:</b> {about}</div>", unsafe_allow_html=True)

        st.markdown(
            f"**Final verdict:** <span class='pill' style='background:{sev_color}'> {severity.title()} </span>",
            unsafe_allow_html=True
        )
        st.success(f"Recommended doctor: **{specialty}**")

        top_one = [{"name": best["name"], "score": best["score"], "base_severity": best["base_severity"], "specialty": best["specialty"]}]
        save_triage(
            patient_id=patient_id,
            selected_symptoms=[f"disease:{disease_guess.strip()}"],
            severity=severity,
            top_conditions=top_one,
            specialty=specialty,
            note=note_text.strip()
        )
        st.toast("Triage saved", icon="üíæ")
        if severity == "serious":
            st.warning("Your input suggests a serious condition. Please seek prompt medical evaluation.")

def patient_chat_ui(assigned_doctor_name: str):
    st.subheader("üí¨ Chat with your assigned doctor")
    if st.session_state.show_chat:
        for msg in st.session_state.chat_messages:
            speaker = "You" if msg["role"] == "patient" else assigned_doctor_name
            st.markdown(f"**{speaker}:** {msg['text']}")
        with st.form("chat_send"):
            txt = st.text_input("Type your message")
            sent = st.form_submit_button("Send")
        if sent and txt.strip():
            st.session_state.chat_messages.append({"role":"patient","text":txt.strip()})
            st.rerun()
    else:
        st.info("Click **Start New Chat** above to begin a conversation.")

def patient_dashboard():
    row = get_patient_by_user_id(st.session_state.user_id)
    patient_id = row[0]
    st.markdown(f"### üè• Patient Dashboard ‚Äî <span class='pill'>Secure</span>", unsafe_allow_html=True)
    st.write(f"Hello, **{row[2]}**!")
    with st.expander("üë§ My Profile", expanded=False):
        c1, c2, c3 = st.columns(3)
        c1.metric("Age", row[3] or "-")
        c2.metric("Gender", row[4] or "-")
        c3.metric("Phone", row[5] or "-")
        st.caption(f"Email: {row[6] or '-'}  |  Address: {row[7] or '-'}")

    st.divider()
    # Assigned doctor & Date of Approval (latest appointment) ‚Äî dd/mm/yy HH:MM
    st.subheader("‚úÖ Doctor Approval")
    latest = get_latest_appointment(patient_id)
    assigned_doctor_name = None
    if latest:
        meet_at = datetime.fromisoformat(latest[1])
        assigned_doctor_name = latest[4]
        st.success(f"Doctor **{latest[4]}** ({latest[5]}) at **{latest[6]}**")
        st.write(f"**Date of Approval / Meeting:** {meet_at.strftime('%d/%m/%y %H:%M')}")
        if latest[2]:
            st.caption(f"Note: {latest[2]}")
    else:
        st.info("No doctor assigned yet. Once a doctor approves and schedules a meeting, it will appear here.")

    if assigned_doctor_name:
        st.markdown(" ")
        patient_chat_ui(assigned_doctor_name)

    st.divider()
    patient_disease_checker(patient_id)

    st.divider()
    st.subheader("üìÖ Appointment History")
    appts = get_patient_appointments(patient_id)
    if not appts.empty:
        appts["meeting_at"] = pd.to_datetime(appts["meeting_at"]).dt.strftime("%d/%m/%y %H:%M")
        appts["created_at"] = pd.to_datetime(appts["created_at"]).dt.strftime("%d/%m/%y %H:%M")
        st.dataframe(appts.rename(columns={
            "meeting_at":"Meeting At (dd/mm/yy)",
            "doctor_name":"Doctor",
            "specialization":"Specialty",
            "hospital_clinic":"Hospital/Clinic",
            "note":"Note",
            "created_at":"Created"
        }), use_container_width=True, hide_index=True)
    else:
        st.caption("No appointments yet.")

    st.divider()
    st.subheader("üìù Optional: Add a Free-Text Note")
    with st.form("symptom_form", clear_on_submit=True):
        symptoms = st.text_area("Notes", placeholder="Anything else you'd like your doctor to know‚Ä¶", height=100)
        duration = st.text_input("Duration", placeholder="e.g., 3 days, 2 weeks (optional)")
        previous_diagnosis = st.text_area("Previous Diagnosis (optional)", placeholder="Any past diagnosis‚Ä¶")
        c1, c2 = st.columns([1,1])
        with c1:
            submitted = st.form_submit_button("Save Note", use_container_width=True)
        with c2:
            exit_btn = st.form_submit_button("Logout", use_container_width=True)
    if submitted:
        if symptoms.strip():
            add_symptom_record(patient_id, symptoms.strip(), duration.strip(), previous_diagnosis.strip())
            st.success("Saved!")
            st.toast("Saved", icon="üíæ")
        else:
            st.error("Please write something in Notes before saving.")
    if exit_btn:
        logout_reset()

# ==============================
# DOCTOR UI
# ==============================
def doctor_registration():
    st.subheader("üë®‚Äç‚öïÔ∏è Doctor Registration")
    with st.form("doctor_reg_form"):
        col1, col2 = st.columns(2)
        with col1:
            username = st.text_input("Username*")
            password = st.text_input("Password*", type="password")
            full_name = st.text_input("Full Name*")
            specialization = st.text_input("Specialization*", placeholder="e.g., Pulmonologist")
        with col2:
            hospital_clinic = st.text_input("Hospital/Clinic Name*")
            phone = st.text_input("Phone Number*")
            email = st.text_input("Email*")
        submitted = st.form_submit_button("Register")
    if submitted:
        if username and password and full_name and specialization and hospital_clinic:
            user_id = create_user(username, password, "doctor")
            if user_id:
                create_doctor(user_id, full_name, specialization, hospital_clinic, phone, email)
                st.success("Registration successful! Please login.")
                st.balloons()
                st.session_state.page = 'main'
                st.rerun()
            else:
                st.error("Username already exists!")
        else:
            st.error("Please fill all required fields!")

def doctor_login():
    st.subheader("üîê Doctor Login")
    with st.form("doctor_login_form"):
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        c1, c2 = st.columns(2)
        with c1:
            submitted = st.form_submit_button("Login", use_container_width=True)
        with c2:
            back = st.form_submit_button("Back", use_container_width=True)
    if submitted:
        user_id = verify_user(username, password, "doctor")
        if user_id:
            st.session_state.logged_in = True
            st.session_state.user_role = "doctor"
            st.session_state.user_id = user_id
            st.toast("Welcome, Doctor!", icon="ü©∫")
            st.rerun()
        else:
            st.error("Invalid credentials!")
    if back:
        st.session_state.page = 'main'
        st.rerun()

def doctor_dashboard():
    drow = get_doctor_by_user_id(st.session_state.user_id)
    doctor_id = drow[0]
    doctor_spec = (drow[3] or "").strip()
    st.markdown(f"### üë®‚Äç‚öïÔ∏è Doctor Dashboard ‚Äî <span class='pill'>{doctor_spec}</span>", unsafe_allow_html=True)
    st.write(f"Welcome, **Dr. {drow[2]}** ({doctor_spec})")
    c1, _ = st.columns([1,3])
    with c1:
        if st.button("üö™ Logout", use_container_width=True):
            logout_reset()
    st.divider()

    # Patients routed to this specialty
    latest_triage = get_latest_triage_per_patient()
    if not latest_triage.empty and doctor_spec:
        routed = latest_triage[ latest_triage["recommended_specialty"].str.contains(doctor_spec, case=False, na=False) ].copy()
    else:
        routed = pd.DataFrame()

    # EXCLUDE patients already assigned to a doctor of the same specialty
    if not routed.empty:
        def _is_taken(pid: int) -> bool:
            return patient_taken_by_specialty(int(pid), doctor_spec)
        routed["taken_same_spec"] = routed["patient_id"].apply(_is_taken)
        triage_for_me = routed[~routed["taken_same_spec"]].drop(columns=["taken_same_spec"]).copy()
        hidden_count = int(routed["taken_same_spec"].sum())
    else:
        triage_for_me = pd.DataFrame()
        hidden_count = 0

    st.subheader("üß≠ Triage (patients routed to you)")
    if hidden_count > 0:
        st.caption(f"‚ÑπÔ∏è {hidden_count} patient(s) hidden because they are already assigned to a doctor with the same specialty.")
    if not triage_for_me.empty:
        with st.expander("üîé Filter", expanded=False):
            name_q = st.text_input("Patient name contains‚Ä¶")
            sev = st.multiselect("Severity", ["mild","moderate","serious"])
            df = triage_for_me.copy()
            if name_q: df = df[df["full_name"].str.contains(name_q, case=False, na=False)]
            if sev: df = df[df["severity"].isin(sev)]
        st.dataframe(df if 'df' in locals() else triage_for_me, use_container_width=True, hide_index=True)
    else:
        st.info("No routed patients available to you right now.")

    st.divider()
    st.subheader("üìÖ Assign Meeting (Approval)")
    if triage_for_me.empty:
        st.caption("No eligible patients to schedule.")
    else:
        pat_opts = (triage_for_me[["patient_id","full_name"]]
                    .drop_duplicates()
                    .sort_values("full_name"))
        pat_display = {int(r["patient_id"]): r["full_name"] for _, r in pat_opts.iterrows()}
        colA, colB = st.columns(2)
        with colA:
            chosen_pid = st.selectbox("Select patient", options=list(pat_display.keys()),
                                      format_func=lambda pid: f"{pat_display[pid]} (#{pid})")
        with colB:
            meet_date = st.date_input("Meeting date", value=date.today())
            meet_time = st.time_input("Meeting time", value=time(10, 0))
        note = st.text_input("Note (optional)", placeholder="e.g., bring previous reports")
        if st.button("Assign Meeting", use_container_width=True):
            # Double-check (race-safe) the patient still not taken by same specialty
            if patient_taken_by_specialty(int(chosen_pid), doctor_spec):
                st.error("This patient has just been assigned to another doctor of the same specialty.")
            else:
                meeting_dt = datetime.combine(meet_date, meet_time)
                create_appointment(patient_id=int(chosen_pid), doctor_id=doctor_id,
                                   meeting_iso=meeting_dt.isoformat(), note=note.strip())
                st.success("Meeting assigned! Patient will see it as Date of Approval.")
                st.toast("Appointment saved", icon="üìÖ")
                st.rerun()

    st.divider()
    st.subheader("üìã Patient Notes (free text) ‚Äî routed to your specialty only (and not already taken)")
    notes_df = get_all_symptom_records_df()
    if not notes_df.empty and not triage_for_me.empty:
        my_pat_ids = set(triage_for_me["patient_id"].tolist())  # already excludes taken ones
        notes_df = notes_df[ notes_df["patient_id"].isin(my_pat_ids) ].copy()
    else:
        notes_df = pd.DataFrame()
    if not notes_df.empty:
        st.dataframe(notes_df.drop(columns=["patient_id"]), use_container_width=True, hide_index=True)
        st.download_button(
            label="üì• Download Notes (CSV)",
            data=notes_df.drop(columns=["patient_id"]).to_csv(index=False),
            file_name=f"patient_notes_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )
    else:
        st.caption("No notes for your routed patients yet.")

# ==============================
# MAIN
# ==============================
def main():
    st.set_page_config(
        page_title="Health Management System",
        page_icon="üè•",
        layout="wide",
        initial_sidebar_state="collapsed",
    )
    init_db()
    init_session_state()

    with st.sidebar:
        st.markdown("### üé® Appearance")
        st.session_state.theme = st.selectbox("Theme", list(THEMES.keys()),
                                              index=list(THEMES.keys()).index(st.session_state.theme))
        st.session_state.dark = st.toggle("Dark mode", value=st.session_state.dark)
        st.caption("Applied instantly ‚ú®")

    inject_css(st.session_state.theme, st.session_state.dark)
    hero("Cloud-Based Health Management System",
         "Patient Disease Checker + Doctor Portal with Scheduling (single app).")

    if st.session_state.logged_in:
        if st.session_state.user_role == "patient":
            patient_dashboard()
        elif st.session_state.user_role == "doctor":
            doctor_dashboard()
        return

    # Landing
    c1, c2 = st.columns(2)
    with c1:
        role_card("üë§", "Patient",
                  "Tell us the disease you think you have. We‚Äôll triage and a suitable doctor can approve a meeting.",
                  [("Patient Login", "patient_login"), ("Patient Registration", "patient_registration")])
    with c2:
        role_card("üë®‚Äç‚öïÔ∏è", "Doctor",
                  "See only patients routed to your specialty (excluding those already assigned) and assign meetings.",
                  [("Doctor Login", "doctor_login"), ("Doctor Registration", "doctor_registration")])

    # Routes
    page = st.session_state.page
    if page == 'patient_login':
        st.divider(); patient_login()
    elif page == 'patient_registration':
        st.divider(); patient_registration()
    elif page == 'doctor_login':
        st.divider(); doctor_login()
    elif page == 'doctor_registration':
        st.divider(); doctor_registration()

    st.divider()
    st.markdown(
        "<div style='text-align:center;color:var(--muted);padding:8px;'>"
        "üè• HMS ‚Ä¢ Educational triage only ‚Äî not a medical diagnosis."
        "</div>",
        unsafe_allow_html=True,
    )

if __name__ == "__main__":
    main()
